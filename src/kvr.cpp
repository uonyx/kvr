/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Copyright (c) 2015 Ubaka Onyechi
 *
 * kvr is free software distributed under the MIT license.
 * See https://raw.githubusercontent.com/uonyx/kvr/master/LICENSE for details.
 */

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#include "kvr.h"
#include "internal/kvr_internal.h"

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

static const char * const kvr_const_str_null  = "null";
static const char * const kvr_const_str_true  = "true";
static const char * const kvr_const_str_false = "false";
static const char * const kvr_const_str_set   = "set";
static const char * const kvr_const_str_add   = "add";
static const char * const kvr_const_str_rem   = "rem";

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

static const uint32_t KVR_VALUE_TYPE_MASK = 0xffffff00;

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// default allocator
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

#if KVR_DEBUG
#define kvr_memory_track_ctr_decl(X) kvr_default_allocator (): m_ctr (0) {} ~kvr_default_allocator () { KVR_ASSERT (m_ctr == 0); } int X
#define kvr_memory_track_ctr_incr(X) X++
#define kvr_memory_track_ctr_decr(X) X--
#else
#define kvr_memory_track_ctr_incr(X)
#define kvr_memory_track_ctr_decr(X)
#define kvr_memory_track_ctr_decl(x)
#endif

#if KVR_CPP11
#define kvr_final final
#else
#define kvr_final 
#endif

static kvr::allocator * get_default_allocator ()
{
  class kvr_default_allocator kvr_final : public kvr::allocator
  {
  public:
    void * allocate (size_t sz)            { kvr_memory_track_ctr_incr (m_ctr); return ::operator new (sz); }
    void   deallocate (void *p, size_t sz) { kvr_memory_track_ctr_decr (m_ctr);  KVR_REF_UNUSED (sz); return ::operator delete (p); }

    kvr_memory_track_ctr_decl (m_ctr);
  };

  static kvr_default_allocator a;
  return &a;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::ctx
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::ctx * kvr::ctx::create (allocator *alloc)
{
  allocator *a = alloc ? alloc : get_default_allocator ();
  void *p = a->allocate (sizeof (kvr::ctx));
  kvr::ctx *ctx = p ? (new (p) kvr::ctx (a)) : NULL;
  return ctx;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::ctx::destroy (kvr::ctx *ctx)
{
  KVR_ASSERT_SAFE (ctx, (void) 0);
  allocator *a = ctx->m_allocator;
  ctx->~ctx ();
  a->deallocate (ctx, sizeof (kvr::ctx));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////



kvr::ctx::ctx (allocator *a) : m_allocator (a), m_keystore (256)
{
  KVR_ASSERT (a);
#if !KVR_OPTIMIZATION_AUTO_CTX_MEMORY_CLEANUP_OFF
  m_vstore.init (8, m_allocator);
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::ctx::~ctx ()
{
#if !KVR_OPTIMIZATION_AUTO_CTX_MEMORY_CLEANUP_OFF
  
  // clean up left-over values
  for (size_t i = 0, c = m_vstore.size (); i < c; ++i)
  {
    kvr::value *v = m_vstore.at (i);
#if 1
    KVR_ASSERT ((v->m_flags & kvr::value::FLAG_PARENT_CTX) != 0);
    this->_destroy_value (kvr::value::FLAG_PARENT_CTX, v);
#else
    this->destroy_value (v);
#endif
  }

  // check left-over keys should have been cleaned up as well
  KVR_ASSERT (m_keystore.empty ());

  // destroy vstore
  m_vstore.deinit (m_allocator);

#else

  // hint that root values have not been freed
  KVR_ASSERT (m_keystore.empty ());

  // clean up left-over keys
  keystore::iterator iter = m_keystore.begin ();  
  while (iter != m_keystore.end ())
  {
    kvr::key *k = (*iter).second;
    KVR_ASSERT (k);
    
    m_allocator->deallocate (k->m_str, k->m_len + 1);
    m_allocator->deallocate (k, sizeof (kvr::key));

    m_keystore.erase (iter);
    iter = m_keystore.begin ();
  }
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::create_value ()
{
  kvr::value *v = this->_create_value_null (kvr::value::FLAG_PARENT_CTX);
#if !KVR_OPTIMIZATION_AUTO_CTX_MEMORY_CLEANUP_OFF
  m_vstore.push_back (v, m_allocator);
#endif
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::ctx::destroy_value (value *v)
{
  if ((v->m_flags & kvr::value::FLAG_PARENT_CTX) == 0) 
    return;
#if !KVR_OPTIMIZATION_AUTO_CTX_MEMORY_CLEANUP_OFF
  m_vstore.remove (v);
#endif
  this->_destroy_value (kvr::value::FLAG_PARENT_CTX, v);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

size_t kvr::ctx::get_key_count ()
{
  size_t count = m_keystore.size ();
  return count;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
#if !KVR_OPTIMIZATION_AUTO_CTX_MEMORY_CLEANUP_OFF
size_t kvr::ctx::get_value_count ()
{
  size_t count = m_vstore.size ();
  return count;
}
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::ctx::dump (int id)
{
#if KVR_DEBUG
  std::fprintf (stderr, "\n--------------------------------\n");
  std::fprintf (stderr, "kvr ctx state debug dump [%02d]\n", id);
  std::fprintf (stderr, "--------------------------------\n");
  std::fprintf (stderr, "load_factor:       %f\n",   m_keystore.load_factor ());
  std::fprintf (stderr, "bucket_count:      %zu\n",  m_keystore.bucket_count ());
  std::fprintf (stderr, "max_size:          %zu\n",  m_keystore.max_size ());
  std::fprintf (stderr, "max_load_factor:   %f\n",   m_keystore.max_load_factor ());
  std::fprintf (stderr, "max_bucket_count:  %zu\n",  m_keystore.max_bucket_count ());
#else
  KVR_REF_UNUSED (id);
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_null (uint32_t parentType)
{
  value *v = _create_value (parentType);
  v->conv_null ();
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_map (uint32_t parentType)
{
  value *v = _create_value (parentType);
  v->conv_map ();
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_array (uint32_t parentType)
{
  value *v = _create_value (parentType);
  v->conv_array ();
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_integer (uint32_t parentType, int64_t number)
{
  value *v = _create_value (parentType);
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_integer ();
#endif
  v->set_integer (number);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_float (uint32_t parentType, double number)
{
  value *v = _create_value (parentType);
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_float ();
#endif
  v->set_float (number);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_boolean (uint32_t parentType, bool boolean)
{
  value *v = _create_value (parentType);
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_boolean ();
#endif
  v->set_boolean (boolean);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value_string (uint32_t parentType, const char *str, sz_t len)
{
  KVR_ASSERT (str);

  value *v = _create_value (parentType);
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_string ();
#endif
  v->set_string (str, len);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::ctx::_create_value (uint32_t parentType)
{
  void *p = m_allocator->allocate (sizeof (kvr::value));
  kvr::value *v = p ? (new (p) kvr::value (this, parentType)) : NULL;
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::ctx::_destroy_value (uint32_t parentType, value *v)
{
  KVR_ASSERT (v);
  KVR_ASSERT ((v->m_flags & parentType) != 0);  
  
  if (v && ((v->m_flags & parentType) != 0))
  {
    v->_destruct ();
    m_allocator->deallocate (v, sizeof (kvr::value));
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key *kvr::ctx::_add_key (const char *str)
{
  KVR_ASSERT (str);

  sz_t len = static_cast<sz_t> (strlen (str));
  char *cstr = (char * ) m_allocator->allocate (len + 1);
  kvr_strcpy (cstr, len + 1, str);

  key *k = this->_create_key (cstr, len);
  if (k && (k->m_ref > 1)) { m_allocator->deallocate (cstr, len + 1); }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::ctx::_add_key_if_not_exists (const char *str) // preferred over '_create_key' if str is likely to already exist
{
  KVR_ASSERT (str);

  key *k = this->_find_key (str);
  if (k)
  {
    k->m_ref++;
  }
  else
  {
    k = this->_add_key (str);
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::ctx::_find_key (const char *str)
{
  KVR_ASSERT (str);

  key *k = NULL;

  keystore::iterator iter = m_keystore.find (str);
  if (iter != m_keystore.end ())
  {
    k = (*iter).second;
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::ctx::_create_key (char *str, sz_t len)
{
  KVR_ASSERT (str);
  KVR_ASSERT (len > 0);

  std::pair<const char *, key *> p (str, NULL);
  std::pair<keystore::iterator, bool> res = m_keystore.insert (p);

  key *k = NULL;
  if (res.second)
  {
    // insert succeeded: update value
    KVR_ASSERT (!res.first->second);
    void *ptr = m_allocator->allocate (sizeof (kvr::key));
    k = res.first->second = ptr ? (new (ptr) kvr::key (str, len)) : NULL;
    k->m_ref = 1;
  }
  else
  {
    // insert failed: key already exists
    KVR_ASSERT (res.first->second);
    k = res.first->second;
    k->m_ref++;
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::ctx::_destroy_key (kvr::key *k)
{
  KVR_ASSERT (k);

  if ((--k->m_ref) == 0)
  {
    m_keystore.erase (k->m_str);
    m_allocator->deallocate (k->m_str, k->m_len + 1);
    m_allocator->deallocate (k, sizeof (kvr::key));
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

char * kvr::ctx::_create_path_expr (const char **path, sz_t pathsz, sz_t *exprsz) const
{
  KVR_ASSERT (pathsz > 0);
  KVR_ASSERT (exprsz);

  char *expr = NULL;

  if (pathsz > 0)
  {
    // pre-calculate key buffer size
    sz_t expsz = 0;
    for (sz_t i = 0; i < pathsz; ++i)
    {
      const char *p = path [i];
      KVR_ASSERT (p);

      size_t plen = strlen (p);
      KVR_ASSERT ((uint64_t) plen <= kvr::SZ_T_MAX);

      expsz += (sz_t) plen;
      expsz += 1; // for delimiter/null character
    }

    if (expsz > 0)
    {
      // create key
      expr = (char *) m_allocator->allocate (expsz);

      char *dst = expr;
      const char delim = KVR_CONSTANT_TOKEN_DELIMITER;

      for (sz_t i = 0; i < pathsz; ++i)
      {
        const char *p = path [i];
        KVR_ASSERT (p);

        while ((*dst++ = *p++) != 0) {}
        *(dst - 1) = delim;
      }

      *(dst - 1) = 0;
    }

    if (exprsz)
    {
      *exprsz = expsz;
    }
  }

  return expr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::ctx::_destroy_path_expr (char *expr, sz_t exprsz)
{
  KVR_ASSERT (expr);

  m_allocator->deallocate (expr, exprsz);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_map (sz_t sz)
{
  return this->_conv_map (sz);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_array (sz_t sz)
{
  return this->_conv_array (sz);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_string ()
{
  if (!is_string ())
  {
    this->_clear ();
    m_flags |= FLAG_TYPE_STRING_STATIC;
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_boolean ()
{
  if (!is_boolean ())
  {
    this->_clear ();
    m_flags |= FLAG_TYPE_BOOLEAN;
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_integer ()
{
  if (!is_integer ())
  {
    if (is_float ())
    {
      int64_t i = static_cast<int64_t> (m_data.n.f);
      m_data.n.i = i;
      m_flags &= ~FLAG_TYPE_NUMBER_FLOAT;
    }
    else
    {
      this->_clear ();
    }

    m_flags |= FLAG_TYPE_NUMBER_INTEGER;
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_float ()
{
  if (!is_float ())
  {
    if (is_integer ())
    {
      double f = static_cast<double> (m_data.n.i);
      m_data.n.f = f;
      m_flags &= ~FLAG_TYPE_NUMBER_INTEGER;
    }
    else
    {
      this->_clear ();
    }

    m_flags |= FLAG_TYPE_NUMBER_FLOAT;
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::conv_null ()
{
  if (!is_null ())
  {
    this->_clear ();
    m_flags |= FLAG_TYPE_NULL;
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_string (const char *str, sz_t len)
{
  KVR_ASSERT_SAFE (str, (void) 0);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_string ());
#else
  conv_string ();
#endif
  this->_string_set (str, len);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_string (const char *str)
{
  KVR_ASSERT_SAFE (str, (void)0);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_string ());
#else
  conv_string ();
#endif
  size_t len = strlen (str);  
  KVR_ASSERT ((uint64_t) len <= SZ_T_MAX);
  this->_string_set (str, (sz_t) len);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_integer (int64_t n)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_integer ());
#else  
  conv_integer ();
#endif

  m_data.n.i = n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_float (double n)
{
  KVR_ASSERT_SAFE ((!kvr::internal::isnan (n) && !kvr::internal::isinf (n) && "n is invalid"), (void) 0);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_float ());
#else  
  conv_float ();
#endif  
  m_data.n.f = n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_boolean (bool b)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_boolean ());
#else
  conv_boolean ();
#endif
  m_data.b = b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char * kvr::value::get_string () const
{
  KVR_ASSERT_SAFE (is_string (), NULL);
  const char *str = this->_is_string_dynamic () ? m_data.s.m_dyn.get () : m_data.s.m_stt.get ();
  return str;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char * kvr::value::get_string (sz_t *len) const
{
  KVR_ASSERT_SAFE (len, get_string ());
  
  const char *str = NULL;

  if (this->_is_string_dynamic ())
  {
    *len = m_data.s.m_dyn.length ();
    str = m_data.s.m_dyn.get ();
  }
  else
  {
    *len = m_data.s.m_stt.length ();
    str = m_data.s.m_stt.get ();
  }

  return str;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

int64_t kvr::value::get_integer () const
{
  KVR_ASSERT_SAFE (this->_is_number (), 0);
  return is_integer () ? m_data.n.i : static_cast<int64_t>(m_data.n.f);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

double kvr::value::get_float () const
{
  KVR_ASSERT_SAFE (this->_is_number (), 0.0f);
  return is_float () ? m_data.n.f : static_cast<double>(m_data.n.i);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::get_boolean () const
{
  KVR_ASSERT_SAFE (is_boolean (), false);
  return m_data.b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (int32_t num)
{
  return this->push (static_cast<int64_t>(num));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (int64_t num)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else  
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_integer (FLAG_PARENT_ARRAY, num);
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (double num)
{
  KVR_ASSERT_SAFE ((!kvr::internal::isnan (num) && !kvr::internal::isinf (num) && "num is invalid"), NULL);
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_float (FLAG_PARENT_ARRAY, num);
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (bool b)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else  
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_boolean (FLAG_PARENT_ARRAY, b);
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (const char *str)
{
  KVR_ASSERT_SAFE (str, NULL);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_string (FLAG_PARENT_ARRAY, str, static_cast<sz_t>(strlen (str)));
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_map ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_map (FLAG_PARENT_ARRAY);
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_array ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_array (FLAG_PARENT_ARRAY);
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_null ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_null (FLAG_PARENT_ARRAY);
  this->m_data.a.push (v, m_ctx->m_allocator);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::pop ()
{
  KVR_ASSERT_SAFE (is_array (), false);

  bool ret = false;

  kvr::value *v = this->m_data.a.pop ();
  if (v)
  {
    m_ctx->_destroy_value (FLAG_PARENT_ARRAY, v);
    ret = true;
  }

  return ret;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::element (kvr::sz_t index) const
{
  KVR_ASSERT_SAFE (is_array (), NULL);  
  kvr::value *v = this->m_data.a.elem (index);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::length () const
{
  KVR_ASSERT_SAFE (is_array (), 0);
  sz_t len = this->m_data.a.m_len;
  return len;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert (const char *keystr, int32_t num)
{
  return this->insert (keystr, static_cast<int64_t>(num));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert (const char *keystr, int64_t num)
{
  KVR_ASSERT (keystr && "invalid input");

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
    n->v->conv_integer ();
#endif
    n->v->set_integer (num);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_integer (FLAG_PARENT_MAP, num), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }

  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert (const char *keystr, double num)
{
  KVR_ASSERT (keystr && "invalid input");
  KVR_ASSERT_SAFE ((!kvr::internal::isnan (num) && !kvr::internal::isinf (num) && "num is invalid"), NULL);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());  
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
    n->v->conv_float ();
#endif
    n->v->set_float (num);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_float (FLAG_PARENT_MAP, num), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }

  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert (const char *keystr, bool b)
{
  KVR_ASSERT (keystr && "invalid input");

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
    n->v->conv_boolean ();
#endif
    n->v->set_boolean (b);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_boolean (FLAG_PARENT_MAP, b), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }

  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert (const char *keystr, const char *str)
{
  KVR_ASSERT (keystr && "invalid input");
  KVR_ASSERT (str && "invalid input");
  
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
    n->v->conv_string ();
#endif
    n->v->set_string (str);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_string (FLAG_PARENT_MAP, str, (sz_t) strlen (str)), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }

  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert_map (const char *keystr)
{
  KVR_ASSERT (keystr && "invalid input");

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
    n->v->conv_map ();
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_map (FLAG_PARENT_MAP), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }

  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert_array (const char *keystr)
{
  KVR_ASSERT (keystr && "invalid input");

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
    n->v->conv_array ();
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_array (FLAG_PARENT_MAP), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }

  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::insert_null (const char *keystr)
{
  KVR_ASSERT (keystr && "invalid input");

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  map::node *n = NULL;
  key *k = m_ctx->_add_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (n)
  {
    n->v->conv_null ();
    m_ctx->_destroy_key (k);    
  }
  else
#endif
  {
    n = m_data.m.insert (k, m_ctx->_create_value_null (FLAG_PARENT_MAP), m_ctx->m_allocator);
    KVR_ASSERT (n);
  }
  
  return n ? n->v : NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::find (const char *keystr) const
{
  KVR_ASSERT (keystr);
  KVR_ASSERT_SAFE (is_map (), NULL);

  key *k = m_ctx->_find_key (keystr);
  if (k)
  {
    map::node *n = this->m_data.m.find (k);
    if (n)
    {
      return n->v;
    }
  }

  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::remove (const char *keystr)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT_SAFE (is_map (), (void) 0);  
  
  key *k = m_ctx->_find_key (keystr);
  if (k)
  {
    map::node *n = this->m_data.m.find (k);
    if (n)
    {
      m_ctx->_destroy_key (n->k);
      m_ctx->_destroy_value (FLAG_PARENT_MAP, n->v);
      m_data.m.remove (n);
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::size () const
{
  KVR_ASSERT_SAFE (is_map (), 0);

#if KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE
  sz_t sz2 = this->m_data.m.size_c ();
#if KVR_DEBUG
  sz_t sz1 = this->m_data.m.size_l ();
  KVR_ASSERT (sz1 == sz2);
#endif
  return sz2;
#else
  return this->m_data.m.size_l ();
#endif
}
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::search (const char *pathexpr) const
{
  KVR_ASSERT_SAFE ((is_map () || is_array ()), NULL);
  KVR_ASSERT_SAFE ((pathexpr && (pathexpr [0] != 0)), NULL);

  value *v = this->_search_path_expr (pathexpr);
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::search (const char **path, sz_t pathsz) const
{
  KVR_ASSERT (is_map () || is_array ());
  KVR_ASSERT_SAFE (path, NULL);

  value *v = (value *) this;

  sz_t pc = 0;
  while (v && (pc < pathsz))
  {
    const char *key = path [pc++];
    v = v->_search_key (key);
  }

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::copy (const value *rhs)
{
  KVR_ASSERT (rhs);
  KVR_ASSERT (this != rhs);

  if (rhs && (this != rhs))
  {
    //////////////////////////////////
    if (rhs->is_map ())
    //////////////////////////////////
    {
      this->_clear ();
      this->conv_map (rhs->size ());

      cursor c (rhs);
      pair rp;
      while (c.get (&rp))
      {
        value *rv = rp.get_value ();
        if (rhs->m_ctx == this->m_ctx)
        {
          KVR_ASSERT (m_ctx->_find_key (rp.get_key ()->get_string ()));
          key *k = rp.get_key (); k->m_ref++;
          value *lv = m_ctx->_create_value_null (FLAG_PARENT_MAP)->copy (rv);          
          this->_insert_kv (k, lv);
        }
        else
        {
          const char *rk = rp.get_key ()->get_string ();
          value *lv = this->insert_null (rk);
          lv->copy (rv);
        }
      }
    }

    //////////////////////////////////
    else if (rhs->is_array ())
    //////////////////////////////////
    {
      this->_clear ();
      sz_t rlen = rhs->length ();
      this->conv_array (rlen);

      for (sz_t i = 0; i < rlen; ++i)
      {
        value *rv = rhs->element (i);
        value *lv = this->push_null ();
        lv->copy (rv);
      }
    }

    //////////////////////////////////
    else if (rhs->is_string ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_string ();
#endif
      const char *str = rhs->get_string ();
      this->set_string (str);
    }

    //////////////////////////////////
    else if (rhs->is_integer ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_integer ();
#endif
      int64_t n = rhs->get_integer ();
      this->set_integer (n);
    }

    //////////////////////////////////
    else if (rhs->is_float ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_float ();
#endif
      double n = rhs->get_float ();
      this->set_float (n);
    }

    //////////////////////////////////
    else if (rhs->is_boolean ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_boolean ();
#endif
      bool b = rhs->get_boolean ();
      this->set_boolean (b);
    }

    //////////////////////////////////
    else if (rhs->is_null ())
    //////////////////////////////////
    {
      this->conv_null ();
    }
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::merge (const value *rhs)
{
  KVR_ASSERT (rhs);
  KVR_ASSERT (this != rhs);
  
  if (rhs && (this != rhs) && this->_type_equiv (rhs))
  {
    //////////////////////////////////
    if (this->is_map ())
    //////////////////////////////////
    {
      // merge top level pairs
      // if pair from [rhs] does not exist in [this], add to [this]
      // if pair.key from [rhs] exists in [this], move to [this]

      value::cursor c (rhs);
      pair rp;

      while (c.get (&rp))
      {
        key *rk = rp.get_key ();
        value *rv = rp.get_value ();

        KVR_ASSERT (rk);
        KVR_ASSERT (rv);

        const char *k = rk->get_string ();
        value *lv = this->find (k);

        if (lv == NULL)
        {
          key *lk = NULL;
          if (m_ctx == rv->m_ctx) // same ctx so simple increment reference count
          {
            lk = rk;
            lk->m_ref++;
          }
          else
          {
            lk = m_ctx->_add_key (k);
          }          
          lv = m_ctx->_create_value_null (FLAG_PARENT_MAP)->copy (rv);
          this->_insert_kv (lk, lv);
        }
        else
        {
          lv->copy (rv);
        }
      }
    }
    //////////////////////////////////
    else if (this->is_array ())
    //////////////////////////////////
    {
      // append
      for (sz_t i = 0, c = rhs->length (); i < c; ++i)
      {
        value *re = rhs->element (i);
        KVR_ASSERT (re);
        this->push_null ()->copy (re); 
      }
    }
    //////////////////////////////////
    else if (this->is_string ())
    //////////////////////////////////
    {
      // append
      sz_t lvlen = 0, rvlen = 0;
      const char *lv = this->get_string (&lvlen);
      const char *rv = rhs->get_string (&rvlen);

      sz_t bufsize = lvlen + rvlen + 1;
      char *buf = (char *) m_ctx->m_allocator->allocate (bufsize);
      kvr_strcpy (buf, bufsize, lv);
      kvr_strcpy ((buf + lvlen), (bufsize - lvlen), rv);

      this->_string_move (buf, bufsize - 1); 
    }
    //////////////////////////////////
    else if (this->is_integer ())
    //////////////////////////////////
    {
      // sum
      int64_t lv = this->get_integer ();
      int64_t rv = rhs->get_integer ();
      this->set_integer (lv + rv);
    }
    //////////////////////////////////
    else if (this->is_float ())
    //////////////////////////////////
    {
      // sum
      double lv = this->get_float ();
      double rv = rhs->get_float ();
      this->set_float (lv + rv);
    }
    //////////////////////////////////
    else if (this->is_boolean ())
    //////////////////////////////////
    {
      // copy
      bool rv = rhs->get_boolean ();
      this->set_boolean (rv);
    }
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::diff (const value *original, const value *modified)
{
  KVR_ASSERT (original);
  KVR_ASSERT (modified);
  KVR_ASSERT (original != modified);
  
  value *diff = this;

  const value *og = original;
  const value *md = modified;

  if (og && md && (og != md) && og->_type_equiv (md))
  {
    //////////////////////////////////
    if (og->is_map () || og->is_array ())
    //////////////////////////////////
    {
      diff->conv_map ();

      value *set = diff->insert_map (kvr_const_str_set);
      value *add = diff->insert_map (kvr_const_str_add);
      value *rem = diff->insert_array (kvr_const_str_rem);

      KVR_ASSERT (set);
      KVR_ASSERT (add);
      KVR_ASSERT (rem);

      const char * path [KVR_CONSTANT_MAX_TREE_DEPTH];
#if KVR_DEBUG
      memset (path, 0, sizeof (path));
#endif
      diff->_diff_set_rem (set, rem, og, md, path, KVR_CONSTANT_MAX_TREE_DEPTH, 0);
#if KVR_DEBUG
      memset (path, 0, sizeof (path));
#endif
      diff->_diff_add (add, og, md, path, KVR_CONSTANT_MAX_TREE_DEPTH, 0);
    }

    //////////////////////////////////
    else if (og->is_string ())
    //////////////////////////////////
    {
      const char *ogstr = og->get_string ();
      const char *mdstr = md->get_string ();
      if (strcmp (ogstr, mdstr) != 0)
      {
        diff->copy (md);
      }
    }

    //////////////////////////////////
    else if (og->is_integer ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->_is_number ());

      if (md->is_integer ())
      {
        int64_t ogn = og->get_integer ();
        int64_t mdn = md->get_integer ();
        if (ogn != mdn)
        {
          diff->copy (md);
        }
      }
      else if (md->is_float ())
      {
        double ogn = og->get_float ();
        double mdn = md->get_float ();
        if (!kvr::internal::fp_equal (ogn, mdn, KVR_CONSTANT_DIFF_FP_EQ_EPSILON))
        {
          diff->copy (md);
        }
      }
    }

    //////////////////////////////////
    else if (og->is_float ())
    //////////////////////////////////
    {
      double ogn = og->get_float ();
      double mdn = md->get_float ();
      if (!kvr::internal::fp_equal (ogn, mdn, KVR_CONSTANT_DIFF_FP_EQ_EPSILON))
      {
        diff->copy (md);
      }
    }

    //////////////////////////////////
    else if (og->is_boolean ())
    //////////////////////////////////
    {
      bool ogb = og->get_boolean ();
      bool mdb = md->get_boolean ();
      if (ogb != mdb)
      {
        diff->copy (md);
      }
    }
  }

  return diff;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::patch (const value *diff)
{
  KVR_ASSERT (diff);
  
  if (diff && diff->is_map () && (this->is_map () || this->is_array ()))
  {
    // patch
    value *set = diff->find (kvr_const_str_set);
    value *add = diff->find (kvr_const_str_add);
    value *rem = diff->find (kvr_const_str_rem);

    KVR_ASSERT (set);
    KVR_ASSERT (add);
    KVR_ASSERT (rem);

    this->_patch_set (set);
    this->_patch_add (add);
    this->_patch_rem (rem);
  }
  else if (diff->is_array ())
  {
    // do nothing.
  }
  else if (diff->_type_equiv (this))
  {
    this->copy (diff);
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

uint32_t kvr::value::hash (uint32_t seed) const
{
  uint32_t hc = seed;

  //////////////////////////////////
  if (this->is_map ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_MAP);
    uint32_t mhc = 0;
    cursor c (this);

    pair p;
    while (c.get (&p))
    {
      const char *k = p.get_key ()->get_string ();
      value *v = p.get_value ();
      uint32_t kh = kvr::internal::strhash (k);
      uint32_t vh = v->hash ();
      mhc ^= (kh * vh);
    }
    hc += mhc;
  }

  //////////////////////////////////
  else if (this->is_array ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_ARRAY);
    uint32_t ahc = 0;
    for (sz_t i = 0, c = this->length (); i < c; ++i)
    {
      value *v = this->element (i);
      uint32_t kh = i;
      uint32_t vh = v->hash ();
      ahc += (kh * vh);
    }
    hc += ahc;
  }

  //////////////////////////////////
  else if (this->is_string ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_STRING_STATIC + FLAG_TYPE_STRING_DYNAMIC);
    const char *str = this->get_string ();
    hc += kvr::internal::strhash (str);
  }

  //////////////////////////////////
  else if (this->is_integer ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_NUMBER_INTEGER);
    uint64_t i = static_cast<uint64_t>(this->get_integer ());
    uint32_t hv = static_cast<uint32_t>((i & 0x00000000ffffffff) ^ (i >> 32));
    hc += hv;
  }

  //////////////////////////////////
  else if (this->is_float ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_NUMBER_FLOAT);
    double f = this->get_float ();
    uint32_t hv = static_cast<uint32_t>(std::floor (f));
    hc += hv;
  }

  //////////////////////////////////
  else if (this->is_boolean ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_BOOLEAN);
    bool b = this->get_boolean ();
    uint32_t hv = b ? 4u : 5u;
    hc += hv;
  }

  //////////////////////////////////
  else if (this->is_null ())
  //////////////////////////////////
  {
    hc += (FLAG_TYPE_NULL);    
  }

  return hc;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::encode (codec_t codec, obuffer *obuf)
{
  KVR_ASSERT_SAFE (obuf, false);

  bool success = false;

  obuf->m_stream.seek (0);

  switch (codec)
  {
    case kvr::CODEC_JSON:
    {
      success = kvr::internal::json::write (this, &obuf->m_stream);
      break;
    }

    case kvr::CODEC_MSGPACK:
    {
      success = kvr::internal::msgpack::write (this, &obuf->m_stream);
      break;
    }

    case kvr::CODEC_CBOR:
    {
      success = kvr::internal::cbor::write (this, &obuf->m_stream);
      break;
    }

    default:
    {
      break;
    }
  }

  return success;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::decode (codec_t codec, const uint8_t *data, size_t size)
{
  bool success = false;

  this->conv_null ();

  mem_istream istr (data, size);

  switch (codec)
  {
    case kvr::CODEC_JSON:
    {
      success = kvr::internal::json::read (this, istr);
      break;
    }

    case kvr::CODEC_MSGPACK:
    {
      success = kvr::internal::msgpack::read (this, istr);
      break;
    }

    case kvr::CODEC_CBOR:
    {
      success = kvr::internal::cbor::read (this, istr);
      break;
    }

    default:
    {
      break;
    }
  }

  return success;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::encode (codec_t codec, ostream *ostr)
{
  KVR_ASSERT_SAFE (ostr, false);

  bool success = false;

  switch (codec)
  {
    case kvr::CODEC_JSON:
    {
      success = kvr::internal::json::write (this, ostr);
      break;
    }

    case kvr::CODEC_MSGPACK:
    {
      success = kvr::internal::msgpack::write (this, ostr);
      break;
    }

    case kvr::CODEC_CBOR:
    {
      success = kvr::internal::cbor::write (this, ostr);
      break;
    }

    default:
    {
      break;
    }
  }

  return success;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::decode (codec_t codec, istream &istr)
{
  bool success = false;

  this->conv_null ();

  switch (codec)
  {
    case kvr::CODEC_JSON:
    {
      success = kvr::internal::json::read (this, istr);
      break;
    }

    case kvr::CODEC_MSGPACK:
    {
      success = kvr::internal::msgpack::read (this, istr);
      break;
    }

    case kvr::CODEC_CBOR:
    {
      success = kvr::internal::cbor::read (this, istr);
      break;
    }

    default:
    {
      break;
    }
  }

  return success;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

size_t kvr::value::encode_bound (codec_t codec) const
{
  size_t size = 0;

  switch (codec)
  {
    case kvr::CODEC_JSON:
    {
      size = kvr::internal::json::write_approx_size (this);
      break;
    }

    case kvr::CODEC_MSGPACK:
    {
      size = kvr::internal::msgpack::write_approx_size (this);
      break;
    }

    case kvr::CODEC_CBOR:
    {
      size = kvr::internal::cbor::write_approx_size (this);
      break;
    }

    default:
    {
      break;
    }
  }

  size = ((size + 7u) & ~7u);

  return size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::dump () const
{
#if KVR_DEBUG
  this->_dump (0, NULL);
  std::fprintf (stderr, "\n");
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_string_set (const char *str, sz_t len)
{
  KVR_ASSERT (str);
  KVR_ASSERT (is_string ());

  if (this->_is_string_static () && (len >= string::stt_str::CAP))
  {
    this->_clear ();
    m_flags |= FLAG_TYPE_STRING_DYNAMIC;
  }
  
  if (this->_is_string_dynamic ())
  {
    this->m_data.s.m_dyn.set (str, len, m_ctx->m_allocator);
  }
  else
  {
    this->m_data.s.m_stt.set (str, len);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_string_move (char *str, sz_t size)
{
  KVR_ASSERT (str);
  KVR_ASSERT (size > 0);
  KVR_ASSERT (is_string ());
  
  this->_clear ();
  m_flags |= FLAG_TYPE_STRING_DYNAMIC;

  m_data.s.m_dyn.m_data = str;
  m_data.s.m_dyn.m_size = size;
  m_data.s.m_dyn.m_len = size - 1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::_search_path_expr (const char *expr, const char **lastkey, value **lastparent) const
{
  KVR_ASSERT (expr);
  KVR_ASSERT (expr [0] != 0);

  value *v = (value *) this;

  const char delim = KVR_CONSTANT_TOKEN_DELIMITER;
  const char *e1 = expr;
  const char *e2 = strchr (e1, delim);

  uint8_t kbuf [256];
  kvr::mem_ostream kos (kbuf, 256);

  while (v && e2)
  {
    sz_t klen = e2 - e1;
    char *k = (char *) kos.push (klen + 1);    
    kvr_strncpy (k, kos.size (), e1, klen);

    v = v->_search_key (k);

    e1 = ++e2;
    e2 = strchr (e1, delim);
    kos.seek (0);
  }

  if (lastparent)
  {
    *lastparent = v;
  }

  if (lastkey)
  {
    *lastkey = e1;
  }

  if (v && e1 && (*e1 != 0))
  {
    v = v->_search_key (e1);
  }

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::_search_key (const char *keystr) const
{
  KVR_ASSERT (keystr);

  value *v = NULL;

  //////////////////////////////////
  if (this->is_map ())
  //////////////////////////////////
  {
    v = this->find (keystr);
  }

  //////////////////////////////////
  else if (this->is_array ())
  //////////////////////////////////
  {
    char k0 = keystr [0];
    switch (k0)
    {
      case KVR_CONSTANT_TOKEN_MAP_GREP: // pattern match in array of maps
      {
        const char eq = '=';
        const char *pattern = &keystr [1];
        const char *s = strchr (pattern, eq);

        if (s)
        {
          sz_t sklen = s - pattern;
          const char *sk = pattern;
          const char *sv = s + 1;

          for (sz_t i = 0, c = this->length (), f = 0; (i < c) && !f; ++i)
          {
            value *m = this->element (i);

            if (m && m->is_map ())
            {
              cursor cur (m);
              pair p;

              while (cur.get (&p))
              {
                key *pk = p.get_key ();
                const char *pks = pk->get_string ();
                sz_t pkslen = pk->get_length ();

                if (pks && (pkslen == sklen) && (strncmp (pks, sk, sklen) == 0)) 
                {
                  // got key (unique), now check value
                  value *pv = p.get_value ();
                  KVR_ASSERT (pv);

                  if (pv->is_string ())
                  {
                    const char *pvstr = pv->get_string ();
                    if (strcmp (sv, pvstr) == 0)
                    {
                      v = m;
                      f = 1;
                    }
                  }
                  else if (pv->is_float ())
                  {
                    double svf = strtod (sv, NULL);
                    double pvf = pv->get_float (); 
                    if (kvr::internal::fp_equal (svf, pvf))
                    {
                      v = m;
                      f = 1;
                    }
                  }
                  else if (pv->is_integer ())
                  {
                    char *end = NULL;
                    int64_t svi = strtoll (sv, &end, 10);
                    int64_t pvi = pv->get_integer ();
                    if (end && (!*end) && (svi == pvi))
                    {
                      v = m;
                      f = 1;
                    }
                  }
                  else if (pv->is_boolean ())
                  {
                    int valid = (strcmp (sv, kvr_const_str_false) == 0) ? 0 : (strcmp (sv, kvr_const_str_true) == 0) ? 1 : -1;
                    if (valid != -1)
                    {
                      bool svb = valid ? true : false;
                      bool pvb = pv->get_boolean ();
                      if (svb == pvb)
                      {
                        v = m;
                        f = 1;
                      }
                    }
                  }
                  else if (pv->is_null ())
                  {
                    bool svnull = (strcmp (sv, kvr_const_str_null) == 0);
                    if (svnull)
                    {
                      v = m;
                      f = 1;
                    }
                  }

                  break;
                }
              }
            }
          }
        }        
        break;
      }

      default:
      {
        char *end = NULL;
        int64_t ki64 = strtoll (keystr, &end, 10);
        KVR_ASSERT_SAFE ((end && (!*end) && "non-integral array index"), NULL);
        KVR_ASSERT (ki64 >= 0);
        KVR_ASSERT ((uint64_t) ki64 <= kvr::SZ_T_MAX);
        sz_t ki = (sz_t) ki64;
        v = this->element (ki);
        break;
      }
    }
  }

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

uint8_t kvr::value::_type () const
{
  uint8_t t = m_flags & ~KVR_VALUE_TYPE_MASK;
  return t;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::_type_equiv (const value *rhs) const
{
  KVR_ASSERT (rhs);

  if ((this->_type () == rhs->_type ()) || 
      (this->_is_number () && rhs->_is_number ()) || 
      (this->is_string () && rhs->is_string ()))
  {
    return true;
  }

  return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_destruct ()
{
  if (this->is_map ())
  {
    cursor c (this);
    pair   p;
    while (c.get (&p))
    {
      m_ctx->_destroy_key (p.m_k);
      m_ctx->_destroy_value (FLAG_PARENT_MAP, p.m_v);      
    }
    m_data.m.deinit (m_ctx->m_allocator);
  }
  else if (this->is_array ())
  {
    sz_t c = this->length ();
    while (c)
    {
      this->pop ();
      c = this->length ();
    }
    m_data.a.deinit (m_ctx->m_allocator);
  }
  else if (this->_is_string_dynamic ())
  {
    m_data.s.m_dyn.cleanup (m_ctx->m_allocator);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_clear ()
{
  // release memory
  this->_destruct ();

  // zero data
  memset (&m_data, 0, sizeof (m_data));

  // clear type flag
  m_flags &= KVR_VALUE_TYPE_MASK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_dump (size_t lpad, const char *key) const
{
#if KVR_DEBUG
  for (size_t t = 0; t < lpad; ++t)
  {
    std::fprintf (stderr, "  ");
  }

  if (key)
  {
    std::fprintf (stderr, "key = %s : ", key);
  }

  //////////////////////////////////
  if (this->is_map ())
  //////////////////////////////////
  {
    std::fprintf (stderr, "value = -> [map]\n");

    cursor c (this);
    pair   p;
    while (c.get (&p))
    {
      const char *k = p.get_key ()->get_string ();
      value *v = p.get_value ();
      v->_dump (lpad + 1, k);
    }
  }

  //////////////////////////////////
  else if (this->is_array ())
  //////////////////////////////////
  {
    std::fprintf (stderr, "value = -> [array]\n");

    char k [21];
    for (sz_t i = 0, c = this->length (); i < c; ++i)
    {
      size_t kl = kvr::internal::u64toa (i, k);
      k [kl] = 0;
      value *v = this->element (i);
      v->_dump (lpad + 1, k);
    }
  }

  //////////////////////////////////
  else if (this->is_string ())
  //////////////////////////////////
  {
    const char *str = get_string ();
    std::fprintf (stderr, "value = %s -> [string]\n", str);
  }

  //////////////////////////////////
  else if (this->is_integer ())
  //////////////////////////////////
  {
    int64_t n = get_integer ();
#if 0
    std::fprintf (stderr, "value = %" PRId64 " -> [int]\n", n);
#else
    // PRId64 not supported by travis-ci
    char ns [22];
    size_t c = kvr::internal::i64toa (n, ns);
    ns [c] = 0;
    fprintf (stderr, "value = %s -> [int]\n", ns);
#endif
  }

  //////////////////////////////////
  else if (this->is_float ())
  //////////////////////////////////
  {
    double n = get_float ();
    std::fprintf (stderr, "value = %g -> [float]\n", n);
  }

  //////////////////////////////////
  else if (this->is_boolean ())
  //////////////////////////////////
  {
    bool b = get_boolean ();
    std::fprintf (stderr, "value = %s -> [bool]\n", b ? kvr_const_str_true : kvr_const_str_false);
  }

  //////////////////////////////////
  else if (this->is_null ())
  //////////////////////////////////
  {
    std::fprintf (stderr, "value = %s -> [null]\n", kvr_const_str_null);
  }
#else
  KVR_REF_UNUSED (lpad);
  KVR_REF_UNUSED (key);
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_diff_set_rem (value *set, value *rem, const value *og, const value *md,
                                const char **path, const sz_t pathsz, sz_t pathcnt)
{
  KVR_ASSERT (set);
  KVR_ASSERT (rem);

  // find og values in md that need to be updated
  // if missing, mark for removal

  if (og)
  {
    //////////////////////////////////
    if (md == NULL)
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      // add og to rem list
      kvr::ctx *ctx = m_ctx;
      value *v = ctx->_create_value_null (FLAG_PARENT_ARRAY);
      v->conv_string ();

      if (pathcnt == 1)
      {
        const char *pk = path [0];
        v->set_string (pk);
      }
      else
      {
        sz_t pksz = 0;
        char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
        v->_string_move (pk, pksz);
      }

      rem->_push_v (v);
    }

    //////////////////////////////////
    else if (!og->_type_equiv (md))
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);

      kvr::ctx *ctx = m_ctx;
      key *k = NULL;
      //if ((pathcnt == 1) && (ctx == og->m_ctx)) // path key must already be in the key store
      if (pathcnt == 1)
      {
        const char *pk = path [0];
        k = (ctx == og->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk); 
      }
      else
      {
        sz_t pksz = 0;
        char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
        KVR_ASSERT (pk && pksz);
        k = ctx->_create_key (pk, pksz - 1);
        if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
      }

      value *v = ctx->_create_value_null (FLAG_PARENT_MAP);
      v->copy (md);
      set->_insert_kv (k, v);
    }

    //////////////////////////////////
    else if (og->is_map ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_map ());

      value::cursor c (og);
      pair ogp;

      while (c.get (&ogp))
      {
        const char *k = ogp.get_key ()->get_string ();

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        value *mdv = md->find (k);
        value *ogv = ogp.get_value ();

        this->_diff_set_rem (set, rem, ogv, mdv, path, pathsz, pathcnt);

        path [--pathcnt] = NULL;
      }
    }

    //////////////////////////////////
    else if (og->is_array ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_array ());

      char k [21];
      for (sz_t i = 0, c = og->length (); i < c; ++i)
      {
        size_t kl = kvr::internal::u64toa (i, k);
        k [kl] = 0;

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        value *mdv = md->element (i);
        value *ogv = og->element (i);

        this->_diff_set_rem (set, rem, ogv, mdv, path, pathsz, pathcnt);

        path [--pathcnt] = NULL;
      }
    }

    //////////////////////////////////
    else if (og->is_string ())
    //////////////////////////////////
    {
      KVR_ASSERT (pathcnt > 0);
      KVR_ASSERT (md->is_string ());

      sz_t mdstrlen = 0;
      const char *ogstr = og->get_string ();
      const char *mdstr = md->get_string (&mdstrlen);

      if (strcmp (ogstr, mdstr) != 0)
      {
        kvr::ctx *ctx = m_ctx;
        key *k = NULL;
        if (pathcnt == 1)
        {
          const char *pk = path [0];
          k = (ctx == og->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk);
        }
        else
        {
          sz_t pksz = 0;
          char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
          KVR_ASSERT (pk && pksz);
          k = ctx->_create_key (pk, pksz - 1);
          if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
        }

        value *v = ctx->_create_value_string (FLAG_PARENT_MAP, mdstr, mdstrlen);
        set->_insert_kv (k, v);
      }
    }

    //////////////////////////////////
    else if (og->is_integer ())
    //////////////////////////////////
    {
      KVR_ASSERT (pathcnt > 0);
      KVR_ASSERT (md->_is_number ());

      if (md->is_integer ())
      {
        int64_t ogn = og->get_integer ();
        int64_t mdn = md->get_integer ();

        if (ogn != mdn)
        {
          kvr::ctx *ctx = m_ctx;
          key *k = NULL;
          if (pathcnt == 1)
          {
            const char *pk = path [0];
            k = (ctx == og->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk);
          }
          else
          {
            sz_t pksz = 0;
            char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
            KVR_ASSERT (pk && pksz);
            k = ctx->_create_key (pk, pksz - 1);
            if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
          }

          value *v = ctx->_create_value_integer (FLAG_PARENT_MAP, mdn);
          set->_insert_kv (k, v);
        }
      }
      else if (md->is_float ())
      {
        double ogn = og->get_float ();
        double mdn = md->get_float ();

        if (!kvr::internal::fp_equal (ogn, mdn, KVR_CONSTANT_DIFF_FP_EQ_EPSILON))
        {
          kvr::ctx *ctx = m_ctx;
          key *k = NULL;
          if (pathcnt == 1)
          {
            const char *pk = path [0];
            k = (ctx == og->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk);
          }
          else
          {
            sz_t pksz = 0;
            char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
            KVR_ASSERT (pk && pksz);
            k = ctx->_create_key (pk, pksz - 1);
            if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
          }

          value *v = ctx->_create_value_float (FLAG_PARENT_MAP, mdn);
          set->_insert_kv (k, v);
        }
      }
    }

    //////////////////////////////////
    else if (og->is_float ())
    //////////////////////////////////
    {
      KVR_ASSERT (pathcnt > 0);
      KVR_ASSERT (md->_is_number ());

      double ogn = og->get_float ();
      double mdn = md->get_float ();

      if (!kvr::internal::fp_equal (ogn, mdn, KVR_CONSTANT_DIFF_FP_EQ_EPSILON))
      {
        kvr::ctx *ctx = m_ctx;
        key *k = NULL;
        if (pathcnt == 1)
        {
          const char *pk = path [0];
          k = (ctx == og->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk);
        }
        else
        {
          sz_t pksz = 0;
          char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
          KVR_ASSERT (pk && pksz);
          k = ctx->_create_key (pk, pksz - 1);
          if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
        }

        value *v = ctx->_create_value_float (FLAG_PARENT_MAP, mdn);
        set->_insert_kv (k, v);
      }
    }

    //////////////////////////////////
    else if (og->is_boolean ())
    //////////////////////////////////
    {
      KVR_ASSERT (pathcnt > 0);
      KVR_ASSERT (md->is_boolean ());

      bool ogb = og->get_boolean ();
      bool mdb = md->get_boolean ();

      if (ogb != mdb)
      {
        kvr::ctx *ctx = m_ctx;
        key *k = NULL;
        if (pathcnt == 1)
        {
          const char *pk = path [0];
          k = (ctx == og->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk);
        }
        else
        {
          sz_t pksz = 0;
          char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
          KVR_ASSERT (pk && pksz);
          k = ctx->_create_key (pk, pksz - 1);
          if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
        }

        value *v = ctx->_create_value_boolean (FLAG_PARENT_MAP, mdb);
        set->_insert_kv (k, v);
      }
    }

    //////////////////////////////////
    else if (og->is_null ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_null ());
      // should already be taken care of in type check
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_diff_add (value *add, const value *og, const value *md,
                            const char **path, const sz_t pathsz, sz_t pathcnt)
{
  KVR_ASSERT (add);

  // go through md and og and look for nodes in md that are not in og

  if (md)
  {
    //////////////////////////////////
    if (og == NULL)
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      // add md to add list

      kvr::ctx *ctx = m_ctx;
      key *k = NULL;      
      //if ((pathcnt == 1) && (ctx == md->m_ctx))
      if (pathcnt == 1)
      {
        const char *pk = path [0];
        k = (ctx == md->m_ctx) ? ctx->_add_key_if_not_exists (pk) : ctx->_add_key (pk);
      }
      else
      {
        sz_t pksz = 0;
        char *pk = ctx->_create_path_expr (path, pathcnt, &pksz);
        KVR_ASSERT (pk && pksz);
        k = ctx->_create_key (pk, pksz - 1);
        if (k->m_ref > 1) { ctx->_destroy_path_expr (pk, pksz); pk = NULL; }
      }

      value *v = ctx->_create_value_null (FLAG_PARENT_MAP);
      v->copy (md);
      add->_insert_kv (k, v);
    }

    //////////////////////////////////
    else if (!og->_type_equiv (md))
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      // case handled by _diff_set_rem (which must be called before _diff_add)
    }

    //////////////////////////////////
    else if (md->is_map ())
    //////////////////////////////////
    {
      KVR_ASSERT (og->is_map ());

      value::cursor c (md);
      pair mdp;

      while (c.get (&mdp))
      {
        const char *k = mdp.get_key ()->get_string ();

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        value *ogv = og->find (k);
        value *mdv = mdp.get_value ();

        _diff_add (add, ogv, mdv, path, pathsz, pathcnt);

        path [--pathcnt] = NULL;
      }
    }

    //////////////////////////////////
    else if (md->is_array ())
    //////////////////////////////////
    {
      KVR_ASSERT (og->is_array ());

      char k [21];
      for (sz_t i = 0, c = md->length (); i < c; ++i)
      {
        size_t kl = kvr::internal::u64toa (i, k); k [kl] = 0;

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        value *ogv = og->element (i);
        value *mdv = md->element (i);

        _diff_add (add, ogv, mdv, path, pathsz, pathcnt);

        path [--pathcnt] = NULL;
      }
    }
  }
}                   

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_patch_set (const value *set)
{
  KVR_ASSERT (set);
  
  kvr::value *tg = this;

  kvr::value::cursor cursor (set);
  kvr::pair p;

  while (cursor.get (&p))
  {
    const char *skey = p.get_key ()->get_string ();
    kvr::value *sval = p.get_value ();
    kvr::value *tgv  = tg->_search_path_expr (skey);

    if (tgv)
    {
      tgv->copy (sval);
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_patch_add (const value *add)
{
  KVR_ASSERT (add);

  value *tg = this;

  kvr::value::cursor cursor (add);
  kvr::pair p;

  while (cursor.get (&p))
  {
    const char *akey = p.get_key ()->get_string ();
    value *aval = p.get_value ();

    const char *tgk = NULL;
    value *tgp = NULL;
    value *tgv = tg->_search_path_expr (akey, &tgk, &tgp);
    KVR_ASSERT (tgv == NULL); // path shouldn't exist but we're interested in key and parent
    KVR_REF_UNUSED (tgv);

    if (tgk && tgp)
    {
      KVR_ASSERT (tgp->is_map () || tgp->is_array ());

      if (tgp->is_map ())
      {
        value *v = tgp->insert_null (tgk);
        KVR_ASSERT (v);
        v->copy (aval);
      }
      else if (tgp->is_array ())
      {
#if KVR_DEBUG
        char *end;
        int64_t ki64 = strtoll (tgk, &end, 10); KVR_ASSERT (!*end);
        KVR_ASSERT (ki64 >= 0);
        KVR_ASSERT ((uint64_t) ki64 <= kvr::SZ_T_MAX);
        sz_t ki = (sz_t) ki64;
        sz_t sz = tgp->length ();
        KVR_ASSERT (ki == sz);
#endif
        value *v = tgp->push_null ();
        v->copy (aval);
      }
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_patch_rem (const value *rem)
{
  KVR_ASSERT (rem);

  value *tg = this;

  for (sz_t c = rem->length (); c >= 1; --c) // start from bottom (for array pop)
  {
    sz_t i = c - 1;

    value *rval = rem->element (i);
    KVR_ASSERT (rval);

    const char *rkey = rval->get_string ();
    KVR_ASSERT (rkey);

    const char *tgk = NULL;
    value *tgp = NULL;
    value *tgv = tg->_search_path_expr (rkey, &tgk, &tgp);

    if (tgp && tgv)
    {
      KVR_ASSERT (tgp->is_map () || tgp->is_array ());

      if (tgp->is_map ())
      {
        KVR_ASSERT (tgv == tgp->find (tgk));
        tgp->remove (tgk);
      }
      else if (tgp->is_array ())
      {
#if KVR_DEBUG
        char *end;
        int64_t ki64 = strtoll (tgk, &end, 10); KVR_ASSERT (!*end);
        KVR_ASSERT (ki64 >= 0);
        KVR_ASSERT ((uint64_t) ki64 <= kvr::SZ_T_MAX);
        sz_t ki = (sz_t) ki64;
        sz_t sz = tgp->length ();
        KVR_ASSERT ((ki + 1) == sz);
#endif
        tgp->pop ();
      }
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_insert_kv (key *k, value *v)
{
  KVR_ASSERT (k);
  KVR_ASSERT (v);
  KVR_ASSERT (is_map ());

  map::node *n = NULL;

#if KVR_DEBUG
  n = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  KVR_ASSERT (n == NULL);
#endif

  n = m_data.m.insert (k, v, m_ctx->m_allocator);
  KVR_ASSERT (n != NULL);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_push_v (value *v)
{
  KVR_ASSERT (v);
  KVR_ASSERT (is_array ());

  this->m_data.a.push (v, m_ctx->m_allocator);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::_conv_map (sz_t cap)
{
  if (!is_map ())
  {
    this->_clear ();
    m_flags |= FLAG_TYPE_MAP;
    m_data.m.init (cap, m_ctx->m_allocator);
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::_conv_array (sz_t cap)
{
  if (!is_array ())
  {
    this->_clear ();
    m_flags |= FLAG_TYPE_ARRAY;
    m_data.a.init (cap, m_ctx->m_allocator);
  }

  return this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::string
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char *kvr::value::string::stt_str::get () const
{
  return m_data;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::string::stt_str::length () const
{
  size_t length = strlen (m_data);
  return (sz_t) length;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::string::stt_str::set (const char *str, sz_t len)
{
  KVR_ASSERT (str);
  KVR_ASSERT (len < stt_str::CAP);
  kvr_strncpy (m_data, string::stt_str::CAP, str, len);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char *kvr::value::string::dyn_str::get () const
{
  return m_data;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::string::dyn_str::length () const
{
  return m_len;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::string::dyn_str::set (const char *str, sz_t len, allocator *a)
{
  KVR_ASSERT (str);
  KVR_ASSERT (len > 0);
  KVR_ASSERT (a);

  sz_t allocsz = ((len + 1) + string::dyn_str::PAD) & ~string::dyn_str::PAD;  
  if (allocsz > m_size)
  {
    if (m_data) { a->deallocate (m_data, m_size); }
    m_data = (char *) a->allocate (allocsz);
    m_size = allocsz;
  }

  kvr_strncpy (m_data, m_size, str, len);
  m_len = len;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::string::dyn_str::cleanup (allocator *a)
{
  KVR_ASSERT (a);

  if (m_data)
  {
    a->deallocate (m_data, m_size);
    m_data = NULL;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::array
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::init (sz_t size, allocator *a)
{
  KVR_ASSERT (size > 0);
  KVR_ASSERT (a);

  sz_t allocsz = kvr::internal::align_size (size, CAP_INCR);
  m_ptr = (kvr::value **) a->allocate (sizeof (kvr::value *) * allocsz);
#if KVR_DEBUG
  memset (m_ptr, 0, sizeof (kvr::value *) * allocsz); // debug-only
#endif
  m_cap = allocsz;
  m_len = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::deinit (allocator *a)
{
  KVR_ASSERT (m_ptr);
  KVR_ASSERT (a);

  a->deallocate (m_ptr, m_cap);
  m_ptr = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::push (value *v, allocator *a)
{
  KVR_ASSERT (v);
  KVR_ASSERT (a);

  if (m_len >= m_cap)
  {
    KVR_ASSERT (m_ptr);

    // resize
    sz_t new_cap = m_cap + CAP_INCR;
    value ** new_ptr = (kvr::value **) a->allocate (sizeof (kvr::value *) * new_cap);
    memcpy (new_ptr, m_ptr, sizeof (kvr::value *) * m_cap);
#if KVR_DEBUG
    memset (new_ptr + m_cap, 0, (sizeof (kvr::value *) * CAP_INCR));
#endif
    a->deallocate (m_ptr, m_cap);

    m_ptr = new_ptr;
    m_cap = new_cap;
  }

  m_ptr [m_len++] = v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value *kvr::value::array::pop ()
{
#if KVR_DEBUG
  value *v = NULL;

  if (m_len > 0)
  {
    v = m_ptr [--m_len];
    m_ptr [m_len] = NULL;
  }
#else
  value *v = (m_len > 0) ? m_ptr [--m_len] : NULL;
#endif

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
#if 0 
kvr::value * kvr::value::array::pop (sz_t index)
{
  value *v = NULL;

  if (index < m_len) // implies m_len > 0
  {
    v = m_ptr [index];

    for (sz_t i = index + 1; i < m_len; ++i)
    {
      m_ptr [i - 1] = m_ptr [i];
    }

    m_ptr [--m_len] = NULL;
  }

  return v;
}
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::array::elem (sz_t index) const
{
  value *v = (index < m_len) ? m_ptr [index] : NULL;

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::map
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::init (sz_t size, allocator *a)
{
  KVR_ASSERT (m_ptr == NULL);
  KVR_ASSERT (a);
  KVR_ASSERT (size > 0); //if (size == 0) { size = 1U; }

  sz_t allocsz = kvr::internal::align_size (size, CAP_INCR);
  m_ptr = (node *) a->allocate (sizeof (node) * allocsz);
  memset (m_ptr, 0, sizeof (node) * allocsz);
  m_cap = allocsz;
  m_len = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::deinit (allocator *a)
{
  KVR_ASSERT (a);

#if KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE
  sz_t cap = _cap ();
#else
  sz_t cap = m_cap;
#endif
  a->deallocate (m_ptr, cap);
  m_ptr = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::map::node *kvr::value::map::insert (key *k, value *v, allocator *a)
{
  KVR_ASSERT (k);
  KVR_ASSERT (v);
  KVR_ASSERT (a);
  KVR_ASSERT (m_ptr);

#if KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE

  sz_t cap = _cap ();
  // first, see if we can garbage-collect removed nodes
  if ((m_len >= cap) && ((m_cap % CAP_INCR) != 0))
  {
    sz_t ir = 0, iw = 0;
    while (ir < cap)
    {
      if (m_ptr [ir].k)
      {
        m_ptr [iw++] = m_ptr [ir++];
      }
      else
      {
        ir++;
      }
    }
    m_len -= (ir - iw);
    m_cap += (ir - iw);
    KVR_ASSERT (m_len < cap);
  }

  // check again
  if (m_len >= cap)
  {
    // resize
    sz_t new_cap = cap + CAP_INCR;
    node *new_ptr = (node *) a->allocate (sizeof (node) * new_cap);    
    memcpy (new_ptr, m_ptr, sizeof (node) * cap);
    memset (new_ptr + cap, 0, (sizeof (node) * CAP_INCR));
    a->deallocate (m_ptr, cap);

    m_ptr = new_ptr;
    m_cap += CAP_INCR;
    KVR_ASSERT (new_cap >= m_cap);
  }
#else

  if (m_len >= m_cap)
  {
    KVR_ASSERT (m_ptr);

    // first, see if we can garbage-collect removed nodes
    sz_t ir = 0, iw = 0;
    while (ir < m_cap)
    {
      if (m_ptr [ir].k)
      {
        m_ptr [iw++] = m_ptr [ir++];
      }
      else
      {
        ir++;
      }
    }
    m_len -= (ir - iw);

    // now check again and if resize if necessary
    if (m_len >= m_cap)
    {
      // resize
      sz_t new_cap = m_cap + CAP_INCR;
      node *new_ptr = (node *) a->allocate (sizeof (node) * new_cap);
      // copy over old nodes and set new nodes to null
      memcpy (new_ptr, m_ptr, sizeof (node) * m_cap);      
      memset (new_ptr + m_cap, 0, (sizeof (node) * CAP_INCR));
      a->deallocate (m_ptr, m_cap);

      m_ptr = new_ptr;
      m_cap = new_cap;
    }
  }

#endif
  node *n = &m_ptr [m_len++];
  n->k = k;
  n->v = v;

  return n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::remove (node *n)
{
  KVR_ASSERT (n);
  KVR_ASSERT (n->k);
  KVR_ASSERT (n->v);
  
  if (m_len > 0)
  {
    n->k = NULL;
    n->v = NULL;
#if KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE
    --m_cap;
#endif
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::map::node *kvr::value::map::find (const key *k) const
{
  KVR_ASSERT (k);

#if KVR_OPTIMIZATION_FAST_MAP_INSERT_ON // search from end (last inserted is active)

#if KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE
  for (sz_t c = _cap (); c >= 1; --c)
#else
  for (sz_t c = m_cap; c >= 1; --c)
#endif
  {
    sz_t i = c - 1;
    node *n = &m_ptr [i];
    if (n->k == k)
    {
      KVR_ASSERT (n->v);
      return n;
    }
  }

#else

#if KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE
  for (sz_t i = 0, c = _cap (); i < c; ++i)
#else
  for (sz_t i = 0, c = m_cap; i < c; ++i)
#endif
  {
    node *n = &m_ptr [i];
    if (n->k == k)
    {
      KVR_ASSERT (n->v);      
      return n;
    }
  }

#endif

  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::map::size_l () const // size in linear time
{
  sz_t size = 0;
  sz_t i = 0;

  while (i < m_len)
  {
    if (m_ptr [i].k)
    {
      KVR_ASSERT (m_ptr [i].v);
      ++size;
    }
    ++i;
  }

  return size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::map::size_c () const // size in constant time
{
  sz_t size = m_cap - (_cap () - m_len);
  return size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::map::_cap () const
{
  // for experimental constant time map size calculator
  // only called if #define KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE is enabled

  sz_t capa = 0;

  // (m_cap >= m_len) otherwise (m_cap % CAP_INCR) == 0) might not be correct 
  // i.e might be less than actual capacity e.g. if m_cap is decremented to multiple of CAP_INCR

  if ((m_cap >= m_len) && ((m_cap % CAP_INCR) == 0))
  {
    capa = m_cap;
  }
  else if (m_len)
  {
    capa = kvr::internal::align_size (m_len, CAP_INCR);
  }
  else
  {
    capa = m_cap;
  }

  return capa;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::cursor
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::cursor::cursor (const value *map) : m_map (map), m_index (0)
{
  KVR_ASSERT (map);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::cursor::get (pair *p)
{
  KVR_ASSERT (p);
  const map::node *n = this->_get ();
  if (p && n)
  {
    KVR_ASSERT (n->k && n->v);
    p->m_k = n->k;
    p->m_v = n->v;
    return true;
  }
  return false;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const kvr::value::map::node * kvr::value::cursor::_get ()
{
  const map::node *n = NULL;

  if (m_map && m_map->is_map ())
  {
    const map *m = &m_map->m_data.m;

    n = (m_index < m->m_len) ? &m->m_ptr [m_index++] : NULL;

    while (n && !n->k)
    {
      KVR_ASSERT (!n->v);
      n = (m_index < m->m_len) ? &m->m_ptr [m_index++] : NULL;
    }
  }

  return n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::mem_ostream
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const size_t kvr::mem_ostream::MIN_BUF_SZ = 64u;

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::mem_ostream::mem_ostream (uint8_t *buf, size_t sz, allocator *alloc) : m_buf (buf), m_sz (sz), m_pos (0), m_btype (BUF_EXTERNAL)
{
  KVR_ASSERT (m_buf);
  KVR_ASSERT (m_sz > 0);

  m_alloc = alloc ? alloc : get_default_allocator ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::mem_ostream::mem_ostream (size_t sz, allocator *alloc) : m_buf (NULL), m_sz (0), m_pos (0), m_btype (BUF_INTERNAL)
{
  m_alloc = alloc ? alloc : get_default_allocator ();
  m_sz = kvr::internal::max (MIN_BUF_SZ, sz);
  m_buf = (uint8_t *) m_alloc->allocate (m_sz); KVR_ASSERT (m_buf);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::mem_ostream::~mem_ostream ()
{
  if (m_btype == BUF_INTERNAL) { m_alloc->deallocate (m_buf, m_sz); }  
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::mem_ostream::put (uint8_t byte)
{
  if (m_pos >= m_sz)
  {
    size_t sz = m_sz + m_sz;
    this->reserve (sz);
  }
  m_buf [m_pos++] = byte;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::mem_ostream::write (uint8_t *bytes, size_t count)
{  
  size_t desired_sz = m_pos + count;
  if (desired_sz > m_sz)
  {
    size_t sz = m_sz;
    do { sz += m_sz; } while (sz < desired_sz);
    this->reserve (sz);
  }
  memcpy (&m_buf [m_pos], bytes, count);
  m_pos += count;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

uint8_t * kvr::mem_ostream::push (size_t count)
{
  size_t desired_sz = m_pos + count;
  if (desired_sz > m_sz)
  {
    size_t sz = m_sz;
    do { sz += m_sz; } while (sz < desired_sz);
    this->reserve (sz);
  }

  uint8_t *ret = &m_buf [m_pos];
  m_pos += count;
  return ret;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

uint8_t * kvr::mem_ostream::pop (size_t count)
{
  if (m_pos >= count)
  {
    m_pos -= count;
    uint8_t *ret = &m_buf [m_pos];
    return ret;
  }
  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const uint8_t * kvr::mem_ostream::buffer () const
{
  return m_buf;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

size_t kvr::mem_ostream::size () const
{
  return m_sz;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

size_t kvr::mem_ostream::tell () const
{
  return m_pos;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::mem_ostream::seek (size_t pos)
{
  m_pos = pos;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::mem_ostream::flush ()
{
  // EOS == 0
  KVR_ASSERT_SAFE ((m_pos < m_sz), (void) 0);
  m_buf [m_pos] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::mem_ostream::reserve (size_t sz)
{
  if (sz > m_sz)
  {
    uint8_t *buf = (uint8_t *) m_alloc->allocate (sz);

    if (m_buf)
    {
      memcpy (buf, m_buf, m_sz);
      if (m_btype == BUF_INTERNAL) { m_alloc->deallocate (m_buf, m_sz); }
    }

    m_buf = buf;
    m_sz = sz;
    m_btype = BUF_INTERNAL;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::mem_istream
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::mem_istream::mem_istream (const uint8_t *buf, size_t sz) : m_buf (buf), m_sz (sz), m_pos (0)
{
  KVR_ASSERT (m_buf);
  KVR_ASSERT (m_sz > 0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const uint8_t * kvr::mem_istream::buffer () const
{
  return m_buf;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

size_t kvr::mem_istream::size () const
{
  return m_sz;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

size_t kvr::mem_istream::tell ()
{
  return m_pos;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

uint8_t kvr::mem_istream::peek ()
{
  return m_buf [m_pos];
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::mem_istream::seek (size_t pos)
{
  m_pos = pos;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::mem_istream::get (uint8_t *byte)
{
  if (m_pos < m_sz)
  {
    *byte = m_buf [m_pos++];
    return true;
  }
  return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::mem_istream::read (uint8_t *bytes, size_t count)
{
  if ((m_pos + count) <= m_sz)
  {
    memcpy (bytes, &m_buf [m_pos], count);
    m_pos += count;
    return true;
  }
  return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const uint8_t * kvr::mem_istream::push (size_t count)
{
  if ((m_pos + count) <= m_sz)
  {
    const uint8_t *start = &m_buf [m_pos];
    m_pos += count;
    return start;
  }
  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const uint8_t * kvr::mem_istream::pop (size_t count)
{
  if (m_pos >= count)
  {
    m_pos -= count;
    const uint8_t *ret = &m_buf [m_pos];
    return ret;
  }
  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
