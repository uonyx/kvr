///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Copyright (c) 2015 Ubaka Onyechi
 *
 * kvr is free software distributed under the MIT license.
 * See https://raw.githubusercontent.com/uonyx/kvr/master/LICENSE for details.
 */

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef KVR_INTERNAL_H
#define KVR_INTERNAL_H

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#include <cstdio>
#include <cmath>
#include <limits>
#if KVR_CPP11
#include <random>
#else
#include <ctime>
#endif

#include "../kvr.h"
#include "rapidjson/internal/itoa.h"
#include "rapidjson/internal/dtoa.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#define KVR_INTERNAL_FLAG_DEBUG_CTX_KEY_STORE_RAND_OFF  (KVR_DEBUG && 0)
#define KVR_INTERNAL_FLAG_REALLOC_TYPE_FIXED            0
#define KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE    (KVR_DEBUG || 0) && KVR_INTERNAL_FLAG_REALLOC_TYPE_FIXED
#define KVR_INTERNAL_FLAG_DEBUG_TYPE_PUNNING_ON         0 // TODO: check compiler?

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#if KVR_DEBUG
#include <cassert>
#define KVR_ASSERT(X) assert(X)
#define KVR_ASSERT_SAFE(X, R) KVR_ASSERT(X)
#else
#define KVR_ASSERT(X) 
#define KVR_ASSERT_SAFE(X, R) do { if (!(X)) { return (R); } } while (0,0)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#define KVR_REF_UNUSED(X) (void)(X)

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#if (RAPIDJSON_ENDIAN == RAPIDJSON_LITTLEENDIAN)
#define KVR_LITTLE_ENDIAN
#else
#define KVR_BIG_ENDIAN
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DBL_EPSILON
#define KVR_DBL_EPSILON DBL_EPSILON
#else
#define KVR_DBL_EPSILON 2.2204460492503131e-16
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#if defined (_MSC_VER)
#define kvr_strcpy(dst, dsz, src) strcpy_s (dst, dsz, src)
#define kvr_strncpy(dst, dsz, src, n) strncpy_s (dst, dsz, src, n)
#define kvr_strdup(src, sz) _strdup (src)
#else
#define kvr_strcpy(dst, dsz, src) { strncpy (dst, src, dsz); dst [dsz - 1] = 0; } 
#define kvr_strncpy(dst, dsz, src, n) { KVR_ASSERT (n < dsz); strncpy (dst, src, n); dst [n] = 0; } 
#define kvr_strdup(src, sz) strndup (src, sz)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

namespace kvr
{
    namespace internal
    {
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline size_t u32toa (uint32_t u32, char dest [11])
        {
            const char* end = kvr_rapidjson::internal::u32toa (u32, dest);
            return (end - dest);
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline size_t u64toa (int64_t i64, char dest [21])
        {
            const char* end = kvr_rapidjson::internal::u64toa (i64, dest);
            return (end - dest);
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline size_t i64toa (int64_t i64, char dest [22])
        {
            const char* end = kvr_rapidjson::internal::i64toa (i64, dest);
            return (end - dest);
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline uint32_t ndigitsu32 (uint32_t u32)
        {
            uint32_t count = kvr_rapidjson::internal::CountDecimalDigit32 (u32);
            return count;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline uint32_t ndigitsi64 (int64_t i64)
        {
#if 0
            int64_t n = i64;
            uint32_t count = (n < 0) ? 1 : 0; // sign
            do
            {
                ++count;
                n /= 10;
            } while (n);
            
            return count;
#else
            uint32_t neg = 0;
            uint64_t u64 = static_cast<uint64_t>(i64);
            if (i64 < 0)
            {
                neg = 1;
                u64 = ~u64 + 1;
            }
            
            if (u64 < 10ULL) return 1 + neg;
            if (u64 < 100ULL) return 2 + neg;
            if (u64 < 1000ULL) return 3 + neg;
            if (u64 < 10000ULL) return 4 + neg;
            if (u64 < 100000ULL) return 5 + neg;
            if (u64 < 1000000ULL) return 6 + neg;
            if (u64 < 10000000ULL) return 7 + neg;
            if (u64 < 100000000ULL) return 8 + neg;
            if (u64 < 1000000000ULL) return 9 + neg;
            if (u64 < 10000000000ULL) return 10 + neg;
            if (u64 < 100000000000ULL) return 11 + neg;
            if (u64 < 1000000000000ULL) return 12 + neg;
            if (u64 < 10000000000000ULL) return 13 + neg;
            if (u64 < 100000000000000ULL) return 14 + neg;
            if (u64 < 1000000000000000ULL) return 15 + neg;
            if (u64 < 10000000000000000ULL) return 16 + neg;
            if (u64 < 100000000000000000ULL) return 17 + neg;
            if (u64 < 1000000000000000000ULL) return 18 + neg;
            if (u64 < 10000000000000000000ULL) return 19 + neg;
            return 20 + neg;
#endif
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline uint16_t byteswap16 (uint16_t val)
        {
            uint16_t swap = (uint16_t) ((val >> 8) | (val << 8));
            return swap;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline uint32_t byteswap32 (uint32_t val)
        {
            uint32_t swap = (uint32_t) (((val >> 24) & 0x000000ff) |
                                        ((val >> 8)  & 0x0000ff00) |
                                        ((val << 8)  & 0x00ff0000) |
                                        ((val << 24) & 0xff000000));
            return swap;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline uint64_t byteswap64 (uint64_t val)
        {
            uint64_t swap = (uint64_t) (((val >> 56) & 0x00000000000000ff) |
                                        ((val >> 40) & 0x000000000000ff00) |
                                        ((val >> 24) & 0x0000000000ff0000) |
                                        ((val >> 8)  & 0x00000000ff000000) |
                                        ((val << 8)  & 0x000000ff00000000) |
                                        ((val << 24) & 0x0000ff0000000000) |
                                        ((val << 40) & 0x00ff000000000000) |
                                        ((val << 56) & 0xff00000000000000));
            return swap;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        uint32_t djb_hash (const char *str, uint32_t seed = 5381) // djbx33x
        {
            KVR_ASSERT (str);
            
            uint32_t hash = seed;
            char c;
            while ((c = *str++) != 0)
            {
                hash = ((hash << 5) + hash) ^ c;
            }
            return hash;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        template<typename T>
        inline const T& min (const T& a, const T& b)
        {
            return (a < b) ? a : b;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        template<typename T>
        inline const T& max (const T& a, const T& b)
        {
            return (a > b) ? a : b;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline sz_t align_size (sz_t s, sz_t align)
        {
            sz_t a = align - 1;
            sz_t as = (s + a) & ~a;
            return as;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline bool isnan (double f)
        {
#if KVR_CPP11
            return std::isnan (f);
#elif defined (_MSC_VER)
            return (_isnan (f) != 0);
#else //#elif defined (__clang__) || defined (__GNUC__)
            // quick nan check (valid for IEEE fp mode only).
            // TODO: more robust nan check
            return (f != f);
#endif
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline bool isinf (double f)
        {
#if KVR_CPP11
            return std::isinf (f);
#elif defined (_MSC_VER)
            return (_finite (f) == 0);
#else //#elif defined (__clang__) || defined (__GNUC__)
            return !kvr::internal::isnan (f) && kvr::internal::isnan (f - f);
#endif
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        inline bool fp_equal (double f1, double f2, double ep = KVR_DBL_EPSILON)
        {
            return (f1 == f2) ? true : (fabs (f1 - f2) <= ep);
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        bool fp_single_to_half (float f, uint16_t *hf)
        {
            KVR_ASSERT (hf);
            
            const uint32_t HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP = 0x38000000;
            const uint32_t HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP = 0x47800000;
            const uint32_t FLOAT_MAX_BIASED_EXP = (0xff << 23);
            
#if KVR_INTERNAL_FLAG_DEBUG_TYPE_PUNNING_ON
            union { float f; uint32_t u; } mem;
            mem.f = f;
            uint32_t x = mem.u;
#else
            uint32_t x = 0;
            KVR_ASSERT (sizeof (x) == sizeof (f));
            memcpy (&x, &f, sizeof (f));
#endif
            uint32_t sign = (uint16_t) (x >> 31);
            uint32_t mantissa = x & ((1 << 23) - 1);
            uint32_t exp = x & FLOAT_MAX_BIASED_EXP;
            
            if ((exp > HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP) && (exp < HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP))
            {
                *hf = (((uint16_t) sign) << 15) |
                (uint16_t) ((exp - HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP) >> 13) |
                (uint16_t) (mantissa >> 13);
                return true;
            }
            
            return false;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        bool fp_half_to_single (uint16_t hf, float *f)
        {
            KVR_ASSERT (f);
            
            const uint32_t HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP = 0x38000000;
            const uint32_t HALF_FLOAT_MAX_BIASED_EXP = (0x1f << 10);
            
            uint32_t sign = (uint32_t) (hf >> 15);
            uint32_t mantissa = (uint32_t) (hf & ((1 << 10) -1));
            uint32_t exp = (uint32_t) (hf & HALF_FLOAT_MAX_BIASED_EXP);
            
            if ((exp != 0x0) && (exp != HALF_FLOAT_MAX_BIASED_EXP))
            {
                mantissa <<= 13;
                exp = (exp << 13) + HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP;
                
#if KVR_INTERNAL_FLAG_DEBUG_TYPE_PUNNING_ON
                union { float f; uint32_t u; } mem;
                mem.u = (sign << 31) | exp | mantissa;
                *f = mem.f;
#else
                uint32_t u = (sign << 31) | exp | mantissa;
                memcpy (f, &u, sizeof (u));
#endif
                return true;
            }
            
            return false;
        }
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KVR_LITTLE_ENDIAN
#define kvr_bigendian16(X) kvr::internal::byteswap16 (static_cast<uint16_t>(X))
#define kvr_bigendian32(X) kvr::internal::byteswap32 (static_cast<uint32_t>(X))
#define kvr_bigendian64(X) kvr::internal::byteswap64 (static_cast<uint64_t>(X))
#else
#define kvr_bigendian16(X) (X)
#define kvr_bigendian32(X) (X)
#define kvr_bigendian64(X) (X)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#include "kvr_json.h"
#include "kvr_msgpack.h"
#include "kvr_cbor.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
