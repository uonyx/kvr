///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Copyright (c) 2015 Ubaka Onyechi
 *
 * kvr is free software distributed under the MIT license.
 * See https://raw.githubusercontent.com/uonyx/kvr/master/LICENSE for details.
 */

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef KVR_INTERNAL_H
#define KVR_INTERNAL_H

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#include <cstdio>
#include <cmath>
#include <limits>

#include "../kvr.h"
#include "rapidjson/internal/itoa.h"
#include "rapidjson/internal/dtoa.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#define KVR_INTERNAL_FLAG_EXPERIMENTAL_FAST_MAP_SIZE  (KVR_DEBUG || 0) && 1
#define KVR_INTERNAL_FLAG_DEBUG_TYPE_PUNNING_ON       0 // TODO: check compiler?

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#if KVR_DEBUG
#include <cassert>
#define KVR_ASSERT(X) assert(X)
#define KVR_ASSERT_SAFE(X, R) KVR_ASSERT(X)
#else
#define KVR_ASSERT(X) 
#define KVR_ASSERT_SAFE(X, R) do { if (!(X)) { return (R); } } while (0,0)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#define KVR_REF_UNUSED(X) (void)(X)

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#if (RAPIDJSON_ENDIAN == RAPIDJSON_LITTLEENDIAN)
#define KVR_LITTLE_ENDIAN
#else
#define KVR_BIG_ENDIAN
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DBL_EPSILON
#define KVR_DBL_EPSILON DBL_EPSILON
#else
#define KVR_DBL_EPSILON 2.2204460492503131e-16
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#if defined (_MSC_VER)
#define kvr_strcpy(dst, dsz, src) strcpy_s (dst, dsz, src)
#define kvr_strncpy(dst, dsz, src, n) strncpy_s (dst, dsz, src, n)
#define kvr_strdup(src, sz) _strdup (src)
#else
#define kvr_strcpy(dst, dsz, src) { strncpy (dst, src, dsz); dst [dsz - 1] = 0; } 
#define kvr_strncpy(dst, dsz, src, n) { KVR_ASSERT (n < dsz); strncpy (dst, src, n); dst [n] = 0; } 
#define kvr_strdup(src, sz) strndup (src, sz)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

namespace kvr
{
  namespace internal
  {
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline size_t u32toa (uint32_t u32, char dest [11])
    {
      const char* end = kvr_rapidjson::internal::u32toa (u32, dest);
      return (end - dest);
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline size_t u64toa (int64_t i64, char dest [21])
    {
      const char* end = kvr_rapidjson::internal::u64toa (i64, dest);
      return (end - dest);
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline size_t i64toa (int64_t i64, char dest [22])
    {
      const char* end = kvr_rapidjson::internal::i64toa (i64, dest);
      return (end - dest);
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline uint32_t ndigitsu32 (uint32_t u32)
    {
      uint32_t count = kvr_rapidjson::internal::CountDecimalDigit32 (u32);
      return count;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline uint32_t ndigitsi64 (int64_t i64)
    {
#if 0
      int64_t n = i64;
      uint32_t count = (n < 0) ? 1 : 0; // sign
      do
      {
        ++count;
        n /= 10;
      } while (n);

      return count;
#else
      uint32_t neg = 0;
      uint64_t u64 = static_cast<uint64_t>(i64);
      if (i64 < 0)
      {
        neg = 1;
        u64 = ~u64 + 1;
      }

      if (u64 < 10ULL) return 1 + neg;
      if (u64 < 100ULL) return 2 + neg;
      if (u64 < 1000ULL) return 3 + neg;
      if (u64 < 10000ULL) return 4 + neg;
      if (u64 < 100000ULL) return 5 + neg;
      if (u64 < 1000000ULL) return 6 + neg;
      if (u64 < 10000000ULL) return 7 + neg;
      if (u64 < 100000000ULL) return 8 + neg;
      if (u64 < 1000000000ULL) return 9 + neg;
      if (u64 < 10000000000ULL) return 10 + neg;
      if (u64 < 100000000000ULL) return 11 + neg;
      if (u64 < 1000000000000ULL) return 12 + neg;
      if (u64 < 10000000000000ULL) return 13 + neg;
      if (u64 < 100000000000000ULL) return 14 + neg;
      if (u64 < 1000000000000000ULL) return 15 + neg;
      if (u64 < 10000000000000000ULL) return 16 + neg;
      if (u64 < 100000000000000000ULL) return 17 + neg;
      if (u64 < 1000000000000000000ULL) return 18 + neg;
      if (u64 < 10000000000000000000ULL) return 19 + neg;
      return 20 + neg;
#endif
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline uint16_t byteswap16 (uint16_t val)
    {
      uint16_t swap = (uint16_t) ((val >> 8) | (val << 8));
      return swap;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline uint32_t byteswap32 (uint32_t val)
    {
      uint32_t swap = (uint32_t) (((val >> 24) & 0x000000ff) |
                                  ((val >> 8)  & 0x0000ff00) |
                                  ((val << 8)  & 0x00ff0000) |
                                  ((val << 24) & 0xff000000));
      return swap;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline uint64_t byteswap64 (uint64_t val)
    {
      uint64_t swap = (uint64_t) (((val >> 56) & 0x00000000000000ff) |
                                  ((val >> 40) & 0x000000000000ff00) |
                                  ((val >> 24) & 0x0000000000ff0000) |
                                  ((val >> 8)  & 0x00000000ff000000) |
                                  ((val << 8)  & 0x000000ff00000000) |
                                  ((val << 24) & 0x0000ff0000000000) |
                                  ((val << 40) & 0x00ff000000000000) |
                                  ((val << 56) & 0xff00000000000000));
      return swap;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    uint32_t strhash (const char *str) // djb hash function (fast)
    {
      KVR_ASSERT (str);

      uint32_t hash = 5381;
      char c;
      while ((c = *str++) != 0)
      {
        hash = ((hash << 5) + hash) + c;
      }
      return hash;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    template<typename T>
    inline const T& min (const T& a, const T& b)
    {
      return (a < b) ? a : b;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    template<typename T>
    inline const T& max (const T& a, const T& b)
    {
      return (a > b) ? a : b;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    
    inline sz_t align_size (sz_t s, sz_t align)
    {
      sz_t a = align - 1;
      sz_t as = (s + a) & ~a;
      return as;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline bool isnan (double f)
    {
#if KVR_CPP11
      return std::isnan (f);
#elif defined (_MSC_VER)
      return (_isnan (f) != 0);
//#elif defined (__clang__) || defined (__GNUC__)
#else
      // quick nan check (valid for IEEE fp mode only). 
      // TODO: more robust nan check
      return (f != f);
#endif
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline bool isinf (double f)
    {
#if KVR_CPP11
      return std::isinf (f);
#elif defined (_MSC_VER)
      return (_finite (f) == 0);
//#elif defined (__clang__) || defined (__GNUC__)
#else
      return !kvr::internal::isnan (f) && kvr::internal::isnan (f - f); // not tested if this works :/
#endif
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    inline bool fp_equal (double f1, double f2, double ep = KVR_DBL_EPSILON)
    {
      return (f1 == f2) ? true : (fabs (f1 - f2) <= ep);
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    bool fp_single_to_half (float f, uint16_t *hf)
    {
      KVR_ASSERT (hf);

      const uint32_t HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP = 0x38000000;
      const uint32_t HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP = 0x47800000;
      const uint32_t FLOAT_MAX_BIASED_EXP = (0xff << 23);

#if KVR_INTERNAL_FLAG_DEBUG_TYPE_PUNNING_ON
      union { float f; uint32_t u; } mem; mem.f = f;
      //union { float f; uint32_t u; } mem = { f };
      uint32_t x = mem.u;
#else
      uint32_t x = 0;
      KVR_ASSERT (sizeof (x) == sizeof (f));
      memcpy (&x, &f, sizeof (f));
#endif
      uint32_t sign = (uint16_t) (x >> 31);      
      uint32_t mantissa = x & ((1 << 23) - 1);
      uint32_t exp = x & FLOAT_MAX_BIASED_EXP;

      if ((exp > HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP) && (exp < HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP))
      {
        *hf = (((uint16_t) sign) << 15) |
              (uint16_t) ((exp - HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP) >> 13) |
              (uint16_t) (mantissa >> 13);
        return true;
      }

      return false;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    bool fp_half_to_single (uint16_t hf, float *f)
    {
      KVR_ASSERT (f);

      const uint32_t HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP = 0x38000000;
      const uint32_t HALF_FLOAT_MAX_BIASED_EXP = (0x1f << 10);

      uint32_t sign = (uint32_t) (hf >> 15);
      uint32_t mantissa = (uint32_t) (hf & ((1 << 10) -1));
      uint32_t exp = (uint32_t) (hf & HALF_FLOAT_MAX_BIASED_EXP);

      if ((exp != 0x0) && (exp != HALF_FLOAT_MAX_BIASED_EXP))
      {
        mantissa <<= 13;
        exp = (exp << 13) + HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP;

#if KVR_INTERNAL_FLAG_DEBUG_TYPE_PUNNING_ON
        union { float f; uint32_t u; } mem;
        mem.u = (sign << 31) | exp | mantissa;
        *f = mem.f;
#else
        uint32_t u = (sign << 31) | exp | mantissa;
        memcpy (f, &u, sizeof (u));
#endif
        return true;
      }
      
      return false;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KVR_LITTLE_ENDIAN
#define kvr_bigendian16(X) kvr::internal::byteswap16 (X)
#define kvr_bigendian32(X) kvr::internal::byteswap32 (X)
#define kvr_bigendian64(X) kvr::internal::byteswap64 (X)
#else
#define kvr_bigendian16(X) (X)
#define kvr_bigendian32(X) (X)
#define kvr_bigendian64(X) (X)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#include "kvr_json.h"
#include "kvr_msgpack.h"
#include "kvr_cbor.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
